#' @title Parse EPA results
#' @description Parse jplace-format results generated by EPA-ng
#' @export
#' @rdname parse_jplace
parse_jplace = function(f,split=1){
  res = treeio::read.jplace(f)
  res.tree = res@phylo
  edgeNum = attr(res.tree,"edgeNum")
  node.tips = get_descendant_tips_for_each_node(res.tree)
  res.uniq.node = unique(res@placements$node)
  cat(sprintf("%d unique partitions found.\n",length(res.uniq.node)))
  node.hash = lapply(node.tips[res.uniq.node],function(x){
    c(sort_and_digest(x),sort_and_digest(setdiff(res.tree$tip.label,x)))
  })
  cat(sprintf("Formatting insert location information\n"))
  place.loc = lapply(1:dim(res@placements)[1],function(i){
    this.des = res@placements$node[i]
    this.parent = getAncestor(res.tree,this.des)
    this.length = res.tree$edge.length[res.tree$edge[,2]==this.des]
    return(list(hash=node.hash[[which(res.uniq.node==this.des)]],
                l=c(res@placements$distal_length[i],
                    this.length-res@placements$distal_length[i],
                    res@placements$pendant_length[i]),
                label=as.character(res@placements$name[i])))
  })
  split.idx = split(x = 1:dim(res@placements)[1],f = mod(1:dim(res@placements)[1],split),
                    drop = TRUE)
  return(lapply(split.idx,function(i){
    list(query=as.character(res@placements$name[i]),
         hash=place.loc[i],
         weight=res@placements$like_weight_ratio[i])
  }))
}
#